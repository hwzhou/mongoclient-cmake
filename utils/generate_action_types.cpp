#include <iostream>
#include <fstream>
#include <string>
#include <list>
#include <algorithm>
#include <sstream>
#include <stdexcept>

#include <boost/bind.hpp>
#include <boost/ref.hpp>

using namespace std;
using namespace boost;

#define PROGRAM_NAME "%(program)"

static string usage_format =
    "Generate action_type.{h,cpp}\n\n"
    "Usage:\n"
    "    " PROGRAM_NAME " <path to action_types.txt> <header file path> <source file path>";

#define ACTION_TYPE_CONSTANTS "%(action_type_constants)"
#define ACTION_TYPE_IDENTIFIERS "%(action_type_identifiers)"

static string header_format =
    "// AUTO-GENERATED FILE DO NOT EDIT\n"
    "// See utils/generate_action_types.cpp\n"
    "// This file is generated by \"Max Zhou\" using CMake.\n"
    "/*    Copyright 2012 10gen Inc.\n"
    " *\n"
    " *    Licensed under the Apache License, Version 2.0 (the \"License\");\n"
    " *    you may not use this file except in compliance with the License.\n"
    " *    You may obtain a copy of the License at\n"
    " *\n"
    " *    http://www.apache.org/licenses/LICENSE-2.0\n"
    " *\n"
    " *    Unless required by applicable law or agreed to in writing, software\n"
    " *    distributed under the License is distributed on an \"AS IS\" BASIS,\n"
    " *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
    " *    See the License for the specific language governing permissions and\n"
    " *    limitations under the License.\n"
    " */\n\n"
    "#pragma once\n\n"
    "#include <iosfwd>\n"
    "#include <map>\n"
    "#include <string>\n\n"
    "#include \"mongo/base/status.h\"\n"
    "#include \"mongo/platform/cstdint.h\"\n\n"
    "namespace mongo {\n\n"
    "    struct ActionType {\n"
    "    public:\n\n"
    "        explicit ActionType(uint32_t identifier) : _identifier(identifier) {};\n"
    "        ActionType() {};\n\n"
    "        uint32_t getIdentifier() const {\n"
    "            return _identifier;\n"
    "        }\n\n"
    "        bool operator==(const ActionType& rhs) const;\n\n"
    "        std::string toString() const;\n\n"
    "        // Takes the string representation of a single action type and returns the corresponding\n"
    "        // ActionType enum.\n"
    "        static Status parseActionFromString(const std::string& actionString, ActionType* result);\n\n"
    "        // Takes an ActionType and returns the string representation\n"
    "        static std::string actionToString(const ActionType& action);\n\n"
    ACTION_TYPE_CONSTANTS "\n"
    "        enum ActionTypeIdentifier {\n"
    ACTION_TYPE_IDENTIFIERS "\n"
    "            actionTypeEndValue, // Should always be last in this enum\n"
    "        };\n\n"
    "        static const int NUM_ACTION_TYPES = actionTypeEndValue;\n\n"
    "    private:\n\n"
    "        uint32_t _identifier; // unique identifier for this action.\n"
    "    };\n\n"
    "    // String stream operator for ActionType\n"
    "    std::ostream& operator<<(std::ostream& os, const ActionType& at);\n\n"
    "} // namespace mongo\n";

#define FROM_STRING_IF_STATEMENTS "%(from_string_if_statements)"
#define TO_STRING_CASE_STATEMENTS "%(to_string_case_statements)"

static string source_format =
    "// AUTO-GENERATED FILE DO NOT EDIT\n"
    "// See utils/generate_action_types.cpp\n"
    "// This file is generated by \"Max Zhou\" using CMake.\n"
    "/*    Copyright 2012 10gen Inc.\n"
    " *\n"
    " *    Licensed under the Apache License, Version 2.0 (the \"License\");\n"
    " *    you may not use this file except in compliance with the License.\n"
    " *    You may obtain a copy of the License at\n"
    " *\n"
    " *    http://www.apache.org/licenses/LICENSE-2.0\n"
    " *\n"
    " *    Unless required by applicable law or agreed to in writing, software\n"
    " *    distributed under the License is distributed on an \"AS IS\" BASIS,\n"
    " *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"
    " *    See the License for the specific language governing permissions and\n"
    " *    limitations under the License.\n"
    " */\n\n"
    "#include \"mongo/pch.h\"\n\n"
    "#include \"mongo/db/auth/action_type.h\"\n\n"
    "#include <iostream>\n"
    "#include <string>\n\n"
    "#include \"mongo/base/status.h\"\n"
    "#include \"mongo/platform/cstdint.h\"\n"
    "#include \"mongo/util/mongoutils/str.h\"\n\n"
    "namespace mongo {\n\n"
    ACTION_TYPE_CONSTANTS "\n"
    "    bool ActionType::operator==(const ActionType& rhs) const {\n"
    "        return _identifier == rhs._identifier;\n"
    "    }\n\n"
    "    std::ostream& operator<<(std::ostream& os, const ActionType& at) {\n"
    "        os << ActionType::actionToString(at);\n"
    "        return os;\n"
    "    }\n\n"
    "    std::string ActionType::toString() const {\n"
    "        return actionToString(*this);\n"
    "    }\n\n"
    "    Status ActionType::parseActionFromString(const std::string& action, ActionType* result) {\n"
    FROM_STRING_IF_STATEMENTS "\n"
    "        return Status(ErrorCodes::FailedToParse,\n"
    "                      mongoutils::str::stream() << \"Unrecognized action privilege string: \"\n"
    "                                                << action,\n"
    "                      0);\n"
    "    }\n\n"
    "    // Takes an ActionType and returns the string representation\n"
    "    std::string ActionType::actionToString(const ActionType& action) {\n"
    "        switch (action.getIdentifier()) {\n"
    TO_STRING_CASE_STATEMENTS
    "        default:\n"
    "                return \"\";\n"
    "        }\n"
    "    }\n\n"
    "} // namespace mongo\n";

string replace_string(string &to_replace, const string &format, const string &replace_with)
{
    string::size_type index = to_replace.find(format);
    to_replace.replace(index, format.length(), replace_with);

    return (to_replace);
}

void usage(const char *program)
{
    cout << replace_string(usage_format, PROGRAM_NAME, program);
}

string parse_name(const string &str)
{
    string::size_type index1 = str.find('\"');
    string::size_type index2 = str.find('\"', index1 + 1);
    if (index1 == string::npos || index2 == string::npos)
    {
        throw runtime_error("Can't parse action_types file, format error");
    }

    return (str.substr(index1 + 1, index2 - index1 - 1));
}

typedef list<string> action_type_list;

void parse_file(const char *filename, action_type_list &action_types)
{
    action_types.clear();

    ifstream infile;
    infile.open(filename, ios_base::in);

    if (!infile.good())
    {
        throw runtime_error((string(filename) + " does not exists").c_str());
    }

    while (!infile.eof())
    {
        string line;
        getline(infile, line);

        if (line.length() > 0)
        {
            if (line[0] == '#')
            {
                // comment line
            }
            else if (line[0] == '\r')
            {
                // empty line
            }
            else
            {
                // action type
                action_types.push_back(parse_name(line));
            }
        }
    }
}

void generate_action_type_constant_header(ostringstream &os, const string &action_type)
{
    os << "        static const ActionType " << action_type << ";" << endl;
}

void generate_action_type_identifier(ostringstream &os, const string &action_type)
{
    os << "            " << action_type << "Value," << endl;
}

void generate_header_file(const char *filename, const action_type_list &action_types)
{
    ostringstream os1;
    for_each(action_types.begin(),
             action_types.end(),
             bind(generate_action_type_constant_header, boost::ref(os1), _1));

    ostringstream os2;
    for_each(action_types.begin(),
             action_types.end(),
             bind(generate_action_type_identifier, boost::ref(os2), _1));

    // replace
    string content = replace_string(header_format, ACTION_TYPE_CONSTANTS, os1.str());
    content = replace_string(content, ACTION_TYPE_IDENTIFIERS, os2.str());

    // write to file
    ofstream out(filename, ios_base::out);
    out << content;
    out.close();
}

void generate_action_type_constant_source(ostringstream &os, const string &action_type)
{
    os << "    const ActionType ActionType::" << action_type << "(" << action_type << "Value);" << endl;
}

void generate_from_string_if_statement(ostringstream &os, const string &action_type)
{
    os << "        if (action == \"" << action_type << "\") {" << endl;
    os << "            *result = " << action_type << ";" << endl;
    os << "            return Status::OK();" << endl;
    os << "        }" << endl;
}

void generate_to_string_case_statement(ostringstream &os, const string &action_type)
{
    os << "        case " << action_type << "Value:" << endl;
    os << "            return \"" << action_type << "\";" << endl;
}

void generate_source_file(const char *filename, const action_type_list &action_types)
{
    ostringstream os1;
    for_each(action_types.begin(),
             action_types.end(), 
             bind(generate_action_type_constant_source, boost::ref(os1), _1));

    ostringstream os2;
    for_each(action_types.begin(),
             action_types.end(),
             bind(generate_from_string_if_statement, boost::ref(os2), _1));

    ostringstream os3;
    for_each(action_types.begin(),
             action_types.end(),
             bind(generate_to_string_case_statement, boost::ref(os3), _1));

    // replace
    string content = replace_string(source_format, ACTION_TYPE_CONSTANTS, os1.str());
    content = replace_string(content, FROM_STRING_IF_STATEMENTS, os2.str());
    content = replace_string(content, TO_STRING_CASE_STATEMENTS, os3.str());

    // write to file
    ofstream out(filename, ios_base::out);
    out << content;
    out.close();
}

int main(int argc, char *argv[])
{
    if (argc < 4)
    {
        usage(argv[0]);
        return 2;
    }

    try
    {
        action_type_list action_types;
        parse_file(argv[1], action_types);

        generate_header_file(argv[2], action_types);
        generate_source_file(argv[3], action_types);
    }
    catch (const exception &e)
    {
        cout << "Error occurred: " << e.what() << endl;
        return 1;
    }
}
